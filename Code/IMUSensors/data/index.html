<!DOCTYPE html>
<html>
<head>
  <title>IMU Sensor Visualization</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      background-color: #f4f4f4;
    }
    .header {
      background-color: #333;
      color: white;
      padding: 10px;
      text-align: center;
      font-size: 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .status {
      font-size: 14px;
      padding: 5px 10px;
      border-radius: 5px;
      background-color: #4CAF50;
      color: white;
    }
    .container {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-around;
      padding: 20px;
    }
    .sensor-box {
      background-color: white;
      border-radius: 5px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      margin: 10px;
      padding: 15px;
      min-width: 300px;
      flex: 1;
    }
    .sensor-title {
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 10px;
      border-bottom: 1px solid #eee;
      padding-bottom: 5px;
    }
    .sensor-canvas {
      width: 100%;
      height: 250px;
      margin-bottom: 10px;
      border: 1px solid #ddd;
    }
    .sensor-data {
      font-size: 14px;
      font-family: monospace;
    }
    .axis-indicator {
      display: flex;
      justify-content: center;
      margin-top: 10px;
    }
    .axis {
      margin: 0 10px;
      display: flex;
      align-items: center;
    }
    .axis-color {
      width: 15px;
      height: 15px;
      margin-right: 5px;
    }
    .x-axis { background-color: red; }
    .y-axis { background-color: green; }
    .z-axis { background-color: blue; }
  </style>
</head>
<body>
  <div class="header">
    <div>IMU Sensor Visualization</div>
    <div id="connection-status" class="status">Connected</div>
  </div>
  
  <div class="container">
    <div class="sensor-box">
      <div class="sensor-title">Sensor Unit 1</div>
      <canvas id="canvas1" class="sensor-canvas" width="300" height="250"></canvas>
      <div id="data1" class="sensor-data">Roll: 0.00°, Pitch: 0.00°, Yaw: 0.00°</div>
      <div class="axis-indicator">
        <div class="axis"><div class="axis-color x-axis"></div>X (Roll)</div>
        <div class="axis"><div class="axis-color y-axis"></div>Y (Pitch)</div>
        <div class="axis"><div class="axis-color z-axis"></div>Z (Yaw)</div>
      </div>
    </div>
    
    <div class="sensor-box">
      <div class="sensor-title">Sensor Unit 2</div>
      <canvas id="canvas2" class="sensor-canvas" width="300" height="250"></canvas>
      <div id="data2" class="sensor-data">Roll: 0.00°, Pitch: 0.00°, Yaw: 0.00°</div>
      <div class="axis-indicator">
        <div class="axis"><div class="axis-color x-axis"></div>X (Roll)</div>
        <div class="axis"><div class="axis-color y-axis"></div>Y (Pitch)</div>
        <div class="axis"><div class="axis-color z-axis"></div>Z (Yaw)</div>
      </div>
    </div>
  </div>
  
  <script>
    // Canvas visualization setup
    const sensorCanvases = [];
    const sensorContexts = [];
    
    // Setup 2D visualization for a sensor
    function setupVisualization(index) {
      const canvasId = `canvas${index + 1}`;
      const canvas = document.getElementById(canvasId);
      const ctx = canvas.getContext('2d');
      
      // Store references
      sensorCanvases[index] = canvas;
      sensorContexts[index] = ctx;
      
      // Initial render
      drawSensor(ctx, canvas.width, canvas.height, 0, 0, 0);
      
      return { canvas, ctx };
    }
    
    // Setup visualizations for both sensors
    setupVisualization(0);
    setupVisualization(1);
    
    // Draw a sensor with given orientation angles
    function drawSensor(ctx, width, height, roll, pitch, yaw) {
      // Clear the canvas
      ctx.clearRect(0, 0, width, height);
      
      // Center of the canvas
      const centerX = width / 2;
      const centerY = height / 2;
      
      // Size of the rectangle representing the sensor
      const sensorWidth = 120;
      const sensorHeight = 60;
      
      // Convert degrees to radians
      const rollRad = roll * Math.PI / 180;
      const pitchRad = pitch * Math.PI / 180;
      const yawRad = yaw * Math.PI / 180;
      
      // Save the current state
      ctx.save();
      
      // Move to the center of the canvas
      ctx.translate(centerX, centerY);
      
      // Apply rotations (yaw is a rotation around the vertical axis)
      ctx.rotate(yawRad);
      
      // Draw the main rectangle
      ctx.fillStyle = '#ddd';
      ctx.fillRect(-sensorWidth/2, -sensorHeight/2, sensorWidth, sensorHeight);
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 2;
      ctx.strokeRect(-sensorWidth/2, -sensorHeight/2, sensorWidth, sensorHeight);
      
      // Apply pitch rotation visually by changing the height
      const pitchEffect = Math.cos(pitchRad);
      
      // Draw direction indicator (front of sensor)
      ctx.fillStyle = '#44a';
      ctx.beginPath();
      ctx.moveTo(sensorWidth/2, 0);
      ctx.lineTo(sensorWidth/2 + 20, -10);
      ctx.lineTo(sensorWidth/2 + 20, 10);
      ctx.closePath();
      ctx.fill();
      
      // Draw roll indicator
      ctx.save();
      ctx.rotate(rollRad);
      ctx.fillStyle = 'red';
      ctx.fillRect(-5, -sensorHeight/2 - 15, 10, 15);
      ctx.restore();
      
      // Draw axes
      // X-axis (roll) - red
      ctx.strokeStyle = 'red';
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(40, 0);
      ctx.stroke();
      
      // Y-axis (pitch) - green
      ctx.strokeStyle = 'green';
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(0, -40 * pitchEffect);
      ctx.stroke();
      
      // Z-axis (yaw) - blue
      ctx.strokeStyle = 'blue';
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(0, 0); // Z-axis would come out of the screen
      ctx.arc(0, 0, 10, 0, 2 * Math.PI);
      ctx.stroke();
      
      // Restore the saved state
      ctx.restore();
    }
    
    // Update sensor visualization with rotation data
    function updateSensorVisualization(sensorId, roll, pitch, yaw) {
      const ctx = sensorContexts[sensorId];
      const canvas = sensorCanvases[sensorId];
      
      if (!ctx || !canvas) {
        console.error("Canvas for sensor " + sensorId + " not found");
        return;
      }
      
      drawSensor(ctx, canvas.width, canvas.height, roll, pitch, yaw);
    }
    
    // Update all sensor visualizations
    function updateSensorVisualizations(data) {
      if (data.sensors) {
        data.sensors.forEach(sensor => {
          const id = sensor.id;
          const orientation = sensor.orientation;
          
          // Update 2D visualization
          updateSensorVisualization(id, orientation.roll, orientation.pitch, orientation.yaw);
          
          // Update text display
          const dataElement = document.getElementById(`data${id + 1}`);
          if (dataElement) {
            dataElement.textContent = `Roll: ${orientation.roll.toFixed(2)}°, Pitch: ${orientation.pitch.toFixed(2)}°, Yaw: ${orientation.yaw.toFixed(2)}°`;
          }
        });
      }
    }
    
    // Handle window resize
    window.addEventListener('resize', () => {
      for (let i = 0; i < 2; i++) {
        const canvas = sensorCanvases[i];
        if (canvas) {
          const rect = canvas.getBoundingClientRect();
          canvas.width = rect.width;
          canvas.height = rect.height;
          
          // Redraw with current values
          const dataElement = document.getElementById(`data${i + 1}`);
          const text = dataElement.textContent;
          const roll = parseFloat(text.match(/Roll: ([-\d.]+)°/)[1]) || 0;
          const pitch = parseFloat(text.match(/Pitch: ([-\d.]+)°/)[1]) || 0;
          const yaw = parseFloat(text.match(/Yaw: ([-\d.]+)°/)[1]) || 0;
          
          drawSensor(sensorContexts[i], canvas.width, canvas.height, roll, pitch, yaw);
        }
      }
    });
    
    // WebSocket connection
    const connectWebSocket = () => {
      const socket = new WebSocket(`ws://${window.location.hostname}/ws`);
      console.log(`Connecting to websocket at ws://${window.location.hostname}/ws`);
      
      socket.onopen = function(e) {
        console.log('WebSocket connection established');
        document.getElementById('connection-status').textContent = 'Connected';
        document.getElementById('connection-status').style.backgroundColor = '#4CAF50';
      };
      
      socket.onmessage = function(event) {
        try {
          const data = JSON.parse(event.data);
          console.log('Received data:', data);
          updateSensorVisualizations(data);
        } catch (error) {
          console.error('Error processing message:', error);
        }
      };
      
      socket.onclose = function(event) {
        console.log('WebSocket connection closed');
        document.getElementById('connection-status').textContent = 'Disconnected';
        document.getElementById('connection-status').style.backgroundColor = '#f44336';
        
        // Try to reconnect after 5 seconds
        setTimeout(connectWebSocket, 5000);
      };
      
      socket.onerror = function(error) {
        console.error('WebSocket error:', error);
        document.getElementById('connection-status').textContent = 'Error';
        document.getElementById('connection-status').style.backgroundColor = '#f44336';
      };
      
      return socket;
    };
    
    // Initialize WebSocket connection
    let websocket = connectWebSocket();
  </script>
</body>
</html>